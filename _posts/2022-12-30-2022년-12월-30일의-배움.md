---
layout: post
title:  "2022년 12월 30일의 배움"
date:   2022-12-30 18:30:00 +0900
tags:
    - til
---

- [오늘](https://github.com/0tak2/KOSAjava/tree/main/Notes/2022-12-30)은 의존성 주입에 대해 배웠다.
  - 한 클래스의 필드에 다른 클래스 타입이 명시되어 있다면, 유지보수성과 재사용성이 떨어진다.
  - 프로그램을 재사용할 떄 코드를 가지고 있는 경우도 있지만, 컴파일된 클래스 파일이나 이들을 압축한 JAR 파일을 재사용해야할 떄도 있다.
  - 그렇다면 소스코드에 수정을 가하지 않고, 컴파일된 상태의 클래스를 재사용해야만 한다.
  - 오늘 수업은 이런 목표를 달성하기 위해 코드를 점차 리팩토링하는 방식으로 진행되었다.
    - 먼저 클래스에서 변경이 필요할 수 있는 메소드를 추상 메소드로 잡는 방법이 있다.
      - 이 경우 재사용할 때 해당 클래스를 상속받으면서 해당 메소드를 오버라이딩 하면 된다.
      - 그러나 다중 상속이 불가하므로 더 이상 새로운 클래스를 상속할 수 없다는 한계가 있다.
    - 그렇다면 변경이 필요한 메소드를 별도의 클래스로 옮기는 방법을 생각할 수 있다.
      - 이 경우 새로운 클래스를 필드에 할당하여 사용할 수 있다.
      - 그러나 클래스의 필드에 명시된 클래스의 이름으로 같은 패키지 내에 클래스를 컴파일하여 위치시켜야 하므로 번거롭다.
      - 클래스 간의 관계가 강하면 재사용이 번거로움을 알 수 있다.
    - 그렇다면 클래스가 아닌 인터페이스를 필드에 할당하면 어떨까?
      - 필드에 명시된 클래스 명에 구속되지 않아도 되기 때문에 결합도가 낮아진 것처럼 보이지만, 인터페이스를 구현한 새로운 클래스의 타입 명이 클래스 내에 명시된다는 점에서 여전히 강결합이다.
  - 대안으로 적용할 수 있는 방법이 의존성 주입이다.
    - 클래스 간의 의존 관계가 아닌, 객체 간의 의존 관계를 만드는 방법이다.
    - 예컨대 의존 관계에 있는 클래스나 인터페이스를 클래스 내에서 생성하지 말고, 생성자 인자를 통해 외부로부터 객체 자체를 받을 수 있도록 구성한다,
    - 재사용시 클래스 외부에서 객체를 만들어 생성자를 통해 주입해주기만 하면 된다.
    - 생성자에서 주입된 객체를 클래스의 필드에 할당하고, 이후 멤버 메서드에서 해당 객체가 필요할 때 필드에 바로 접근하면 된다.